<!DOCTYPE html>
<html>
  <head>
    <title>Vert.x / Clojure</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      @import url(http://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(http://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(http://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Vert.x / Clojure

### NYC Clojure Meetup, July 2014

@johnchapin

---

## Vert.x elevator pitch
### Lightweight
### Platform for microservices
### Polyglot language support
### Actor-like concurrency

---

## Language support

- Clojure
- Groovy
- Java
- Javascript
- Python
- Ruby
- Scala

---

## Vert.x "instance"
### JVM per instance
### Event loop (thread) per core
### Many verticles per event loop

---

## Verticles
### Fundamental unit of execution
### "Single threaded"
###  No blocking!
### Worker verticles for blocking
### Horizontal scaling

---

## Modules
### Deployable/resolvable (Maven)
### Compose multiple verticles, dependencies, other modules
### Startup, Configuration

---

## High Availability
### Requires a cluster
### Per-module
### Failover triggered by unclean instance termination
### HA modules are re-started on live cluster node
### HA groups

---

## Event bus messaging
### Handlers registered to addresses
### Point to point
- Round-robin to registered handlers

### Pub/sub
- All registered handlers

### Request/response
- Send, reply, reply, reply...

---

## Shared data
### Shared per Vert.x instance (not to cluster)
### Immutable (yay!)
### Maps
### Sets

---

## Core API
### Event bus and shared data
### Network servers and clients
- (Netty - TCP, UDP, HTTP, Websockets)

### Timers
### Buffers
### File system access
### Configuration

---

## Clojure Support
### Officially supported as of Vert.x 2.1
### ~1 year old

## Tooling/libraries
### lein-vertx
### ring-vertx-adapter

---

### [Vert.x Homepage](http://vertx.io)

### [mod-lang-clojure](https://github.com/vert-x/mod-lang-clojure)

### [Toby Crawley, Developing Asynchronous Polyglot Applications with vert.x](http://youtu.be/MXrNAXGOSOg)

[lein-vertx](https://github.com/isaiah/lein-vertx)

[ring-vertx-adapter](https://github.com/stream1984/ring-vertx-adapter)

---

## vertx-chat

### Core
- Loads config and other verticles

### Logger
- Stores messages
- Responds to history requests

### Timestamper
- Emits timestamp messages

### Web
- Serves html/js/css
- Bridges eventbus to client

---

Backup slides

---

## What is Vert.x?

Vert.x is a lightweight, high performance, **polyglot** application platform.

## Key Concepts

### Verticles &amp; Modules

Verticles are the most basic unit of a Vert.x application, and are the building blocks of Vert.x modules. Modules are resolvable and deployable units composed of other modules and verticles.

### Event bus

The Vert.x event bus is a distributed peer-to-peer messaging system allowing verticles to communicate with each other.

---

## Wait... Polyglot?

Vert.x 2.1 supports the following languages:

- Clojure
- Groovy
- Java
- Javascript
- Python
- Ruby
- Scala

---

## Let's dive right in...

Vert.x instance = JVM instance

Vert.x instances can be clustered on the same host and across a network

Verticles run in a managed thread pool (# of available cores)

Verticles are never executed by more than one thread concurrently

Blocking your verticle will block other verticles

---

## The Eventbus

### Backed by Hazelcast - "The Leading Open Source In-Memory Data Grid"
- Distributed Java data structures and concurrency tools
- Dynamic discovery / scaling / partitioning / fail-over

- TODO: Call me maybe?

---

## Eventbus Messaging

### Addressing
- Addresses are strings.
- Handlers are registered for addresses.

### Topologies
- Pub/sub - all handlers receive the message
- Point to point - one handler receives the message
 - Round-robin "load balancing"
 - Request/response with handlers

### Messages
- Transient!
- Primitive types, Strings, JSON

---

##

---

## Basic verticle

```clojure
(ns net.boostrot.vertx.examples.basic
  (:require [vertx.embed :as vertx]
            [vertx.eventbus :as eb]))

; Embedded vertx (vs. running on cmd line)
(vertx/set-vertx! (vertx/vertx))

; Event bus address
(def address "examples.basic")

; Message handler
(eb/on-message
  address
  (fn [msg]
    (println "Received message:" msg)
    (eb/reply :pong)))

; Message sender
(defn ping []
  (eb/send address :ping #(println "Received reply:" %)))
```

---

## Testing!
### vertx.testtools

```clojure
(ns net.boostrot.vertx.examples.test
  (:require [clojure.test :refer :all]
            [vertx.eventbus :as eb]
            [vertx.testtools :as tt]))

(clojure.test/use-fixtures :each tt/as-embedded)

(deftest foo
  (eb/on-message "address"
    (fn [m]
      (tt/test-complete
        (is (= m {:foo "bar"})))))
  (eb/send "address" {:foo :bar}))
```

---

## Testing...

```clojure
(ns net.boostrot.vertx.examples.test
  (:require [clojure.test :refer :all]
            [vertx.eventbus :as eb]
            [vertx.testtools :as tt]))

(clojure.test/use-fixtures :each tt/as-embedded)

; (binding [*embedded-latch* (CountDownLatch. 1)
;           core/*vertx* (vertx.embed/vertx)]
;   (try
      (deftest foo
        (eb/on-message "address"
          (fn [m]
            (tt/test-complete
              (is (= m {:foo "bar"}))
;               (.countdown *embedded-latch*)
              )))
        (eb/send "address" {:foo :bar}))
;     (finally
;       (if (.await *embedded-latch* timeout)
;         (.stop vertx.core/*vertx*)
;         (throw (Exception. "Timed out..."))))))
```

## Testing gotchas




    </textarea>
    <script src="remark-latest.min.js" type="text/javascript"></script>
    <script type="text/javascript">
      var slideshow = remark.create();
      </script>
    </body>
  </html>
